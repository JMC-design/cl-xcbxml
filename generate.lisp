(in-package :xparser)

;;;; CLX generators

(generate "constant"(:constant (f! "(defconstant ~a ~a)" (caadr constant) (cdadr constant))))
(generate "request" (:request (gen-request request ext)))
(generate "error"   (:xerror (f! "(define-generic-error ~a)" (caadr error))))
(generate "type"    (:type  (f! "(deftype ~A () '~a)" (caadr type) (cdadr type))))
(generate "event"   (:xevent (f! "(declare-event :~a~{~%  ~a~})~%" (caadr event)(third event)))) 
(generate "enum"    (:mask (f! "(define-mask ~a ~a)" (cadr enum) (cddr enum)))
	            (:set (f! "(define-set ~a ~a) " (cadr enum) (cddr enum))))
(generate "struct"  (:struct (let ((name (extensify-name (car (second struct))(getf (x-name ext) :short))))
			       (f! "(define-x-struct ~a ~{~%  ~a~})~%" name (caddr struct)))))

(defun compute-fn-args (fields)
  (let ((args '()))
    (dolist (field fields)
      (case (intern (string-upcase (car field)) :keyword)
	(:list (push (third field) args))
	((:pad :doc))			;we don't need no stinkin pads
	(otherwise (push (second field) args))))
    (setf args (reverse args))
    (unless (intersection args *drawable-providers* :test #'string-equal)
      (push "display" args))
    args))
(defun compute-declarations (fields)
  (let ((decls '((type display "display"))))
    (dolist (field fields)
      (case (intern (string-upcase (car field)) :keyword)
	(:list (push `(type (clx-list ,(second field)) ,(third field)) decls)) ;FIXME for VOIDs 
	((:pad :doc))			;Whats in a pad?
	(otherwise (push `(type ,(first field) ,(second field)) decls))))
    (reverse decls)))
(defun compute-let (args)
  (let ((bindings '()))
    (when (not (find "display" args :test #'equal))
      (push `(display (drawable-display ,(car (intersection args *drawable-providers* :test #'equal))))bindings))
    bindings))
(defun compute-send (fields)
  (when fields
    (let ((result '()))
      (dolist (field fields)
	(let ((type (car field))
	      (var (cdr field)))
	  (case (intern (string-upcase (car field)) :keyword)
	    (:list (push `((sequence \:format ,(first var)),(second var))result))
	    (:pad (push `(fixme var ,var type ,type)result))
	    (:doc)
	    (otherwise (push field result)))))
      (nreverse result))))
(defun compute-receive (fields)
  (when fields
    (let ((first (pop fields))
	  (result '())
	  (index 8))
      (when (not (equal (car first) "pad")) ;silently discard pads in first position
	(push `(,(getify (car first)) 1 ,(cadr first)) result))
      (dolist (field fields)
	(let ((type (car field))
	      (var (cdr field)))
	  (case (intern (string-upcase (car field)) :keyword)
	    (:list (push `(,(second var) (sequence-get \:format ,(first var) \:length ,(third var)))result))
					;fixme sequence-get/put only for card/int 8 16 32
					;(incf index (* (get-size (car var)) (third var)))
					;sequences usually come at end, check RandR req #4
	    (:pad (incf index (parse-integer (car var))))
	    (:doc) 
	    (otherwise (push `(,(car var) (,(getify type) ,index)) result)))
	  (incf index (get-size type))))
      ;(when (equal))
      (nreverse result))))
(defun gen-request (request ext)
  (let* ((ext-name (getf (x-name ext) :xname))
	 (send  (caddr request))
	 (computed-send (compute-send send))
	 (receive (compute-receive (cadddr request)))
	 (fn-name (string-downcase (extensify-name (caadr request) (getf (x-name ext) :short))))
	 (fn-args (compute-fn-args send))	 
	 (type-decls (compute-declarations send))
	 (bindings (compute-let fn-args))
	 (fn-opcode (cdadr request))
	 (sizes (intersection '(8 16 32) (mapcar (lambda (unit) (* 8 (get-size (car unit))))send))))
    (push fn-name (x-exports ext))
    (if receive
	(s+
	 (f! "(defun ~a (~{~a~^ ~})~%" fn-name fn-args)
	 (f! "~@[~2T(let (~{~a~})~%~]" bindings)
	 (f! "  (declare ~{~a~^~%~11T~})" type-decls)
	 (f! "~%  (with-buffer-request-and-reply (display (extension-opcode display ~s) nil ~@[:sizes ~a~])" ext-name sizes)
	 (f! "~%                                 ((data ~a)" fn-opcode)
	 (f! "~{~%~34T~a~^~})" computed-send)
	 (f! "~%  (let* (~{~a~^~%~8T~})" receive)
	 (f! "~%    (values ~{~a~^~%~12T~}))))" (mapcar #'car receive))
	 (f! "~@[)~]" bindings) ;close let
	 (f! "~%"))				
	(s+
	 (f! "(defun ~a (~{~a~^ ~})~%" fn-name fn-args)
	 (f! "~@[~2T(let (~{~a~})~%~]" bindings)
	 (f! "  (declare ~{~a~^~%~11T~})" type-decls)
	 (f! "~%  (with-buffer-request (display (extension-opcode display ~S))" ext-name)
	 (f! "~%                                 ((data ~a)" fn-opcode)
	 (f! "~{~%~34T~a~^~})))" computed-send)
	 (f! "~@[)~]" bindings);close let
	 (f! "~%")))))				


(defun ext->clx (extension)
  "Takes a parsed extension and returns an EXTENSION struct all parsed to work with clx."
  (let ((ext (make-extension :name (x-name extension) :code extension			     
			     :event-vector (list->vector (x-events extension))
			     :error-vector (list->vector (x-errors extension))
			     :request-vector (list->vector (x-requests extension))
			     :constants (generate-clx-constants extension)
			     :enums (generate-clx-enums extension)
			     :structs (generate-clx-structs extension)
			     :types (generate-clx-types extension)
			     :errors (generate-clx-errors extension)
			     :events (generate-clx-events extension)
			     :requests (generate-clx-requests extension)
			     :exports (x-exports extension))))
    (reversef (x-exports ext))
    (setf *current* ext)))

;; (defun gen-clx-request (request)
;;   (let* ((ext-name (getf (x-name *current*) :xname))
;; 	 (send (caddr request))
;; 	 (fn-name (extensify-name (caadr request)))
;; 	 (fn-constant (s+ '+ fn-name '+))
;; 	 (fn-args (mapcar #'(lambda (x) (cdr x)) send))
;; 	 (reply? (/= 0 (length (fourth request))))
;; 	 (sizes '(8 16 32))
;; 	 (opcode)
;; 	 (declarations)
;; 	 (vars)	
;; 	 (receive ))
;;     (if reply?
;; 	`(defun ,fn-name (,@fn-args)
;; 	   (let ((display))
;; 	     (declare (,declarations))
;; 	     (with-buffer-request-and-reply (display (extension-opcode display ,ext-name) nil :sizes ,sizes)
;; 		 ((data ,fn-constant)
;; 		  ,@send)
;; 	       (values ,receive))))
;; 	`(defun ,fn-name (,@fn-args)
;; 	   (let ((display ))
;; 	     (declare (,declarations))
;; 	     (with-buffer-request (display ,opcode)
;; 	       ((data ,fn-constant)
;; 		,@send)))))))
